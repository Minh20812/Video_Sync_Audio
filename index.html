<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Video Player - Episode Control</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        color: #fff;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        min-height: 100vh;
        padding: 20px;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      h1 {
        text-align: center;
        margin-bottom: 30px;
        font-size: 2rem;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }
      .player-wrapper {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
      }
      .episode-info {
        text-align: center;
        margin-bottom: 15px;
        font-size: 1.2rem;
        font-weight: 600;
        color: #4fc3f7;
      }
      video {
        width: 100%;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        margin-bottom: 15px;
      }
      audio {
        width: 100%;
        margin-bottom: 15px;
        border-radius: 8px;
      }
      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
        margin-bottom: 20px;
      }
      button {
        padding: 10px 20px;
        border-radius: 8px;
        border: none;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
      }
      button:active {
        transform: translateY(0);
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }
      .episode-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 10px;
        margin-top: 20px;
      }
      .episode-btn {
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid transparent;
        transition: all 0.3s ease;
      }
      .episode-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: #4fc3f7;
      }
      .episode-btn.active {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        border-color: #f5576c;
        box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
      }
      .status {
        text-align: center;
        margin-top: 15px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        font-size: 14px;
        color: #4fc3f7;
      }
      .sync-info {
        display: flex;
        justify-content: space-around;
        margin-top: 10px;
        font-size: 12px;
        color: #aaa;
      }
      select {
        padding: 10px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.1);
        color: #e97c7c;
        border: 2px solid #667eea;
        font-size: 14px;
        cursor: pointer;
        min-width: 250px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üé¨ Video Player Pro</h1>

      <div class="player-wrapper">
        <div style="margin-bottom: 15px; text-align: center">
          <select id="movieSelector"></select>
        </div>

        <div class="episode-info" id="episodeInfo">ƒêang t·∫£i...</div>

        <video id="video" controls></video>
        <audio id="audio" controls crossorigin="anonymous"></audio>

        <div class="controls">
          <button id="prevBtn">‚èÆÔ∏è T·∫≠p tr∆∞·ªõc</button>
          <button id="syncBtn">üîÑ ƒê·ªìng b·ªô Audio</button>
          <button id="nextBtn">‚è≠Ô∏è T·∫≠p sau</button>
        </div>

        <div class="status" id="status">ƒêang t·∫£i...</div>
        <div class="sync-info">
          <span id="videoTime">Video: 0:00</span>
          <span id="audioTime">Audio: 0:00</span>
          <span id="drift">Drift: 0.00s</span>
        </div>

        <div class="episode-grid" id="episodeGrid"></div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
      // ===== CONFIG - S·ª¨ D·ª§NG GITHUB RAW URL =====
      // Option 1: GitHub Raw (c·∫≠p nh·∫≠t ngay l·∫≠p t·ª©c)
      const CONFIG_URL =
        "https://raw.githubusercontent.com/Minh20812/NoteBook_YT_thuyetminh/main/config.json";

      // Option 2: jsDelivr CDN (nhanh h∆°n, cache 12h)
      // const CONFIG_URL = 'https://cdn.jsdelivr.net/gh/Minh20812/NoteBook_YT_thuyetminh@main/config.json';

      // Fallback config n·∫øu kh√¥ng load ƒë∆∞·ª£c
      const FALLBACK_CONFIG = {
        movies: [
          {
            name: "Qu√°i v·∫≠t: C√¢u Chuy·ªán C·ªßa Ed Gein",
            apiUrl: "https://phimapi.com/tmdb/tv/286801",
            tmdbId: "286801",
            skipStart: 30,
            skipEnd: 62,
          },
          {
            name: "B√≠ M·∫≠t Tri·ªáu ƒê√¥",
            apiUrl: "https://phimapi.com/tmdb/tv/285205",
            tmdbId: "285205",
            skipStart: 900,
            skipEnd: 932,
          },
        ],
        currentMovieIndex: 0,
      };

      let CONFIG = null;
      let skipStart, skipEnd;
      let episodes = [];
      let currentEpisode = 0;
      let hls = null;
      let adSkipped = false;
      let userSeeking = false;
      let isSkippingAd = false;

      const video = document.getElementById("video");
      const audio = document.getElementById("audio");
      const episodeInfo = document.getElementById("episodeInfo");
      const status = document.getElementById("status");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const syncBtn = document.getElementById("syncBtn");
      const episodeGrid = document.getElementById("episodeGrid");
      const movieSelector = document.getElementById("movieSelector");

      // ===== LOAD CONFIG =====
      async function loadConfig() {
        try {
          status.textContent = "‚è≥ ƒêang t·∫£i c·∫•u h√¨nh t·ª´ GitHub...";

          const response = await fetch(CONFIG_URL, {
            cache: "no-cache",
            headers: {
              Accept: "application/json",
            },
          });

          if (!response.ok) throw new Error(`HTTP ${response.status}`);

          const rawData = await response.json();

          // Chuy·ªÉn ƒë·ªïi format t·ª´ opensubtitles_data.json
          if (rawData.movies) {
            // Format chu·∫©n
            CONFIG = rawData;
          } else {
            // Format t·ª´ opensubtitles_data.json (object v·ªõi key l√† t√™n phim)
            CONFIG = {
              movies: Object.entries(rawData).map(([name, data]) => ({
                name: name,
                apiUrl: data.api_url,
                tmdbId: data.tmdb_id,
                skipStart: data.skip_start,
                skipEnd: data.skip_end,
              })),
              currentMovieIndex: 0,
            };
            console.log("üîÑ ƒê√£ chuy·ªÉn ƒë·ªïi format t·ª´ opensubtitles_data.json");
          }

          console.log("‚úÖ ƒê√£ t·∫£i", CONFIG.movies.length, "phim t·ª´ GitHub");
          status.textContent = `‚úÖ ƒê√£ t·∫£i ${CONFIG.movies.length} phim`;
        } catch (error) {
          console.warn("‚ö†Ô∏è L·ªói t·∫£i config:", error.message);
          console.log("üì¶ S·ª≠ d·ª•ng config d·ª± ph√≤ng");
          CONFIG = FALLBACK_CONFIG;
          status.textContent = "‚ö†Ô∏è D√πng config d·ª± ph√≤ng";
        }

        const movie = CONFIG.movies[CONFIG.currentMovieIndex];
        skipStart = movie.skipStart;
        skipEnd = movie.skipEnd;

        initMovieSelector();
        fetchEpisodes();
      }

      function initMovieSelector() {
        movieSelector.innerHTML = "";
        CONFIG.movies.forEach((movie, index) => {
          const option = document.createElement("option");
          option.value = index;
          option.textContent = movie.name;
          movieSelector.appendChild(option);
        });

        movieSelector.value = CONFIG.currentMovieIndex;
        movieSelector.addEventListener("change", (e) => {
          CONFIG.currentMovieIndex = parseInt(e.target.value);
          const movie = CONFIG.movies[CONFIG.currentMovieIndex];
          skipStart = movie.skipStart;
          skipEnd = movie.skipEnd;
          fetchEpisodes();
        });
      }

      async function fetchEpisodes() {
        try {
          const currentMovie = CONFIG.movies[CONFIG.currentMovieIndex];
          status.textContent = "üîÑ ƒêang t·∫£i d·ªØ li·ªáu t·ª´ API...";

          const response = await fetch(currentMovie.apiUrl);
          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

          const data = await response.json();

          if (!data.status || !data.episodes || data.episodes.length === 0) {
            throw new Error("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu t·∫≠p phim");
          }

          const tmdbId = data.movie?.tmdb?.id || currentMovie.tmdbId;
          const season = data.movie?.tmdb?.season || 1;
          const serverData = data.episodes[0].server_data;
          const isMovie = currentMovie.apiUrl.includes("/movie/");

          if (isMovie) {
            episodes = [
              {
                name: serverData[0].name,
                video: serverData[0].link_m3u8,
                audio: `https://archive.org/download/movie_tmdb_${tmdbId}/movie_tmdb_${tmdbId}.ogg`,
              },
            ];
          } else {
            episodes = serverData.map((ep, index) => {
              const episodeNum = index + 1;
              return {
                name: ep.name,
                video: ep.link_m3u8,
                audio: `https://archive.org/download/s${season}_e${episodeNum}_tv_tmdb_${tmdbId}/s${season}_e${episodeNum}_tv_tmdb_${tmdbId}.ogg`,
              };
            });
          }

          console.log(
            "‚úÖ ƒê√£ t·∫£i",
            episodes.length,
            isMovie ? "phim" : "t·∫≠p phim"
          );
          createEpisodeButtons();
          loadEpisode(0);
        } catch (error) {
          console.error("‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu:", error);
          status.textContent = `‚ùå L·ªói: ${error.message}`;
          status.style.color = "#ff6b6b";
        }
      }

      function createEpisodeButtons() {
        episodeGrid.innerHTML = "";
        episodes.forEach((ep, idx) => {
          const btn = document.createElement("button");
          btn.className = "episode-btn";
          btn.textContent = ep.name;
          btn.onclick = () => loadEpisode(idx);
          episodeGrid.appendChild(btn);
        });
      }

      function updateEpisodeButtons() {
        const buttons = episodeGrid.querySelectorAll(".episode-btn");
        buttons.forEach((btn, idx) => {
          btn.classList.toggle("active", idx === currentEpisode);
        });
        prevBtn.disabled = currentEpisode === 0;
        nextBtn.disabled = currentEpisode === episodes.length - 1;
      }

      function loadEpisode(index) {
        if (index < 0 || index >= episodes.length) return;

        currentEpisode = index;
        const ep = episodes[index];

        episodeInfo.textContent = ep.name;
        status.textContent = `ƒêang t·∫£i ${ep.name}...`;
        adSkipped = false;

        if (hls) hls.destroy();

        if (Hls.isSupported()) {
          hls = new Hls();
          hls.loadSource(ep.video);
          hls.attachMedia(video);
          hls.on(Hls.Events.MANIFEST_PARSED, () => {
            status.textContent = `${ep.name} - S·∫µn s√†ng ph√°t`;
          });
        } else if (video.canPlayType("application/vnd.apple.mpegurl")) {
          video.src = ep.video;
        }

        audio.src = ep.audio;
        updateEpisodeButtons();
      }

      prevBtn.onclick = () => loadEpisode(currentEpisode - 1);
      nextBtn.onclick = () => loadEpisode(currentEpisode + 1);

      video.addEventListener("play", () => audio.play());
      video.addEventListener("pause", () => audio.pause());

      video.addEventListener("seeking", () => {
        if (!isSkippingAd) userSeeking = true;
      });

      video.addEventListener("seeked", () => {
        if (userSeeking) {
          const t = video.currentTime;
          const adDuration = skipEnd - skipStart;

          if (t >= skipEnd) {
            audio.currentTime = t - adDuration;
            console.log(
              `üéØ Sync: Video ${t.toFixed(2)}s ‚Üí Audio ${(
                t - adDuration
              ).toFixed(2)}s`
            );
          } else {
            audio.currentTime = t;
          }
        }
        userSeeking = false;
        isSkippingAd = false;
      });

      video.addEventListener("timeupdate", () => {
        const t = video.currentTime;
        if (!adSkipped && t >= skipStart && t < skipEnd) {
          console.log("‚è© Skipping ads...");
          isSkippingAd = true;
          adSkipped = true;
          video.currentTime = skipEnd;
        }
      });

      syncBtn.onclick = () => {
        const t = video.currentTime;
        const adDuration = skipEnd - skipStart;

        if (t >= skipEnd) {
          audio.currentTime = t - adDuration;
          status.textContent = `‚úÖ ƒê·ªìng b·ªô: Video ${formatTime(
            t
          )} ‚Üí Audio ${formatTime(t - adDuration)}`;
        } else {
          audio.currentTime = t;
          status.textContent = `‚úÖ ƒê√£ ƒë·ªìng b·ªô t·∫°i ${formatTime(t)}`;
        }

        setTimeout(() => {
          status.textContent = `${episodes[currentEpisode].name} - ƒêang ph√°t`;
        }, 3000);
      };

      video.addEventListener("ended", () => {
        if (currentEpisode < episodes.length - 1) {
          status.textContent = "‚è≠Ô∏è T·ª± ƒë·ªông chuy·ªÉn t·∫≠p sau 3 gi√¢y...";
          setTimeout(() => {
            loadEpisode(currentEpisode + 1);
            video.play();
          }, 3000);
        } else {
          status.textContent = "üéâ ƒê√£ xem h·∫øt t·∫•t c·∫£ t·∫≠p!";
        }
      });

      function formatTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, "0")}`;
      }

      setInterval(() => {
        if (!video.paused) {
          const drift = (video.currentTime - audio.currentTime).toFixed(2);
          document.getElementById(
            "videoTime"
          ).textContent = `Video: ${formatTime(video.currentTime)}`;
          document.getElementById(
            "audioTime"
          ).textContent = `Audio: ${formatTime(audio.currentTime)}`;
          document.getElementById("drift").textContent = `Drift: ${drift}s`;
        }
      }, 1000);

      // ===== START APP =====
      loadConfig();
    </script>
  </body>
</html>
