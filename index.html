<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Video Player - Episode Control</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        color: #fff;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        min-height: 100vh;
        padding: 20px;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      h1 {
        text-align: center;
        margin-bottom: 30px;
        font-size: 2rem;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }
      .player-wrapper {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
      }
      .episode-info {
        text-align: center;
        margin-bottom: 15px;
        font-size: 1.2rem;
        font-weight: 600;
        color: #4fc3f7;
      }
      video {
        width: 100%;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        margin-bottom: 15px;
      }
      audio {
        width: 100%;
        margin-bottom: 15px;
        border-radius: 8px;
      }
      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
        margin-bottom: 20px;
      }
      button {
        padding: 10px 20px;
        border-radius: 8px;
        border: none;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
      }
      button:active {
        transform: translateY(0);
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }
      .episode-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 10px;
        margin-top: 20px;
      }
      .episode-btn {
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid transparent;
        transition: all 0.3s ease;
      }
      .episode-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: #4fc3f7;
      }
      .episode-btn.active {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        border-color: #f5576c;
        box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
      }
      .status {
        text-align: center;
        margin-top: 15px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        font-size: 14px;
        color: #4fc3f7;
      }
      .sync-info {
        display: flex;
        justify-content: space-around;
        margin-top: 10px;
        font-size: 12px;
        color: #aaa;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üé¨ Video Player Pro</h1>

      <div class="player-wrapper">
        <!-- Movie selector -->
        <div style="margin-bottom: 15px; text-align: center">
          <select
            id="movieSelector"
            style="
              padding: 10px;
              border-radius: 8px;
              background: rgba(255, 255, 255, 0.1);
              color: rgb(233, 124, 124);
              border: 2px solid #667eea;
              font-size: 14px;
              cursor: pointer;
              min-width: 250px;
            "
          ></select>
        </div>

        <div class="episode-info" id="episodeInfo">ƒêang t·∫£i...</div>

        <video id="video" controls></video>
        <audio id="audio" controls crossorigin="anonymous"></audio>

        <div class="controls">
          <button id="prevBtn">‚èÆÔ∏è T·∫≠p tr∆∞·ªõc</button>
          <button id="syncBtn">üîÑ ƒê·ªìng b·ªô Audio</button>
          <button id="nextBtn">‚è≠Ô∏è T·∫≠p sau</button>
        </div>

        <div class="status" id="status">ƒêang t·∫£i...</div>
        <div class="sync-info">
          <span id="videoTime">Video: 0:00</span>
          <span id="audioTime">Audio: 0:00</span>
          <span id="drift">Drift: 0.00s</span>
        </div>

        <div class="episode-grid" id="episodeGrid"></div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
      // ===== CONFIGURATION =====
      const CONFIG = {
        // Danh s√°ch c√°c phim
        movies: [
          {
            name: "Qu√°i v·∫≠t: C√¢u Chuy·ªán C·ªßa Ed Gein",
            apiUrl: "https://phimapi.com/tmdb/tv/286801",
            tmdbId: "286801",
            skipStart: 30,
            skipEnd: 62,
          },
          {
            name: "B√≠ M·∫≠t Tri·ªáu ƒê√¥",
            apiUrl: "https://phimapi.com/tmdb/tv/285205",
            tmdbId: "285205",
            skipStart: 15 * 60,
            skipEnd: 15 * 60 + 32,
          },
          {
            name: "Nguy√™n T·ªôi C·ªßa Takopi",
            apiUrl: "https://phimapi.com/tmdb/tv/284445",
            tmdbId: "284445",
            skipStart: 30,
            skipEnd: 62,
          },
          {
            name: "Hi·ªán Tr∆∞·ªùng V·ª• √Ån S·ªë 0",
            apiUrl: "https://phimapi.com/tmdb/tv/298698",
            tmdbId: "298698",
            skipStart: 28,
            skipEnd: 60,
          },
        ],
        currentMovieIndex: 3, // Phim ƒëang xem
      };

      let skipStart = CONFIG.movies[CONFIG.currentMovieIndex].skipStart;
      let skipEnd = CONFIG.movies[CONFIG.currentMovieIndex].skipEnd;

      let episodes = [];
      const video = document.getElementById("video");
      const audio = document.getElementById("audio");
      const episodeInfo = document.getElementById("episodeInfo");
      const status = document.getElementById("status");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const syncBtn = document.getElementById("syncBtn");
      const episodeGrid = document.getElementById("episodeGrid");
      const movieSelector = document.getElementById("movieSelector");

      let currentEpisode = 0;
      let hls = null;
      let adSkipped = false;
      let userSeeking = false;
      let isSkippingAd = false;

      // ===== POPULATE MOVIE SELECTOR =====
      function initMovieSelector() {
        CONFIG.movies.forEach((movie, index) => {
          const option = document.createElement("option");
          option.value = index;
          option.textContent = movie.name;
          movieSelector.appendChild(option);
        });

        movieSelector.value = CONFIG.currentMovieIndex;
        movieSelector.addEventListener("change", (e) => {
          CONFIG.currentMovieIndex = parseInt(e.target.value);
          const movie = CONFIG.movies[CONFIG.currentMovieIndex];
          skipStart = movie.skipStart;
          skipEnd = movie.skipEnd;
          fetchEpisodes();
        });
      }

      // ===== FETCH DATA FROM API =====
      async function fetchEpisodes() {
        try {
          const currentMovie = CONFIG.movies[CONFIG.currentMovieIndex];
          status.textContent = "üîÑ ƒêang t·∫£i d·ªØ li·ªáu t·ª´ API...";

          const response = await fetch(currentMovie.apiUrl);
          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

          const data = await response.json();

          if (!data.status || !data.episodes || data.episodes.length === 0) {
            throw new Error("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu t·∫≠p phim");
          }

          // L·∫•y TMDB ID t·ª´ d·ªØ li·ªáu
          const tmdbId = data.movie?.tmdb?.id || currentMovie.tmdbId;
          const season = data.movie?.tmdb?.season || 1;

          // L·∫•y server ƒë·∫ßu ti√™n (th∆∞·ªùng l√† server ch·∫•t l∆∞·ª£ng t·ªët nh·∫•t)
          const serverData = data.episodes[0].server_data;

          // X·ª≠ l√Ω d·ªØ li·ªáu th√†nh format ph√π h·ª£p
          episodes = serverData.map((ep, index) => {
            const episodeNum = index + 1;
            return {
              name: ep.name,
              video: ep.link_m3u8,
              audio: `https://archive.org/download/s${season}_e${episodeNum}_tv_tmdb_${tmdbId}/s${season}_e${episodeNum}_tv_tmdb_${tmdbId}.ogg`,
            };
          });

          console.log("‚úÖ ƒê√£ t·∫£i", episodes.length, "t·∫≠p phim");
          console.log("üì∫ TMDB ID:", tmdbId);
          console.log("üé¨ Season:", season);

          createEpisodeButtons();
          loadEpisode(0);
        } catch (error) {
          console.error("‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu:", error);
          status.textContent = `‚ùå L·ªói: ${error.message}`;
          status.style.color = "#ff6b6b";
        }
      }

      // Create episode buttons
      function createEpisodeButtons() {
        episodeGrid.innerHTML = ""; // Clear existing buttons
        episodes.forEach((ep, idx) => {
          const btn = document.createElement("button");
          btn.className = "episode-btn";
          btn.textContent = ep.name;
          btn.onclick = () => loadEpisode(idx);
          episodeGrid.appendChild(btn);
        });
      }

      function updateEpisodeButtons() {
        const buttons = episodeGrid.querySelectorAll(".episode-btn");
        buttons.forEach((btn, idx) => {
          btn.classList.toggle("active", idx === currentEpisode);
        });
        prevBtn.disabled = currentEpisode === 0;
        nextBtn.disabled = currentEpisode === episodes.length - 1;
      }

      function loadEpisode(index) {
        if (index < 0 || index >= episodes.length) return;

        currentEpisode = index;
        const ep = episodes[index];

        episodeInfo.textContent = ep.name;
        status.textContent = `ƒêang t·∫£i ${ep.name}...`;

        // Reset ad skip flag
        adSkipped = false;

        // Load video
        if (hls) {
          hls.destroy();
        }

        if (Hls.isSupported()) {
          hls = new Hls();
          hls.loadSource(ep.video);
          hls.attachMedia(video);
          hls.on(Hls.Events.MANIFEST_PARSED, () => {
            status.textContent = `${ep.name} - S·∫µn s√†ng ph√°t`;
          });
        } else if (video.canPlayType("application/vnd.apple.mpegurl")) {
          video.src = ep.video;
        }

        // Load audio
        audio.src = ep.audio;

        updateEpisodeButtons();
      }

      // Navigation
      prevBtn.onclick = () => loadEpisode(currentEpisode - 1);
      nextBtn.onclick = () => loadEpisode(currentEpisode + 1);

      // Sync controls
      video.addEventListener("play", () => audio.play());
      video.addEventListener("pause", () => audio.pause());

      video.addEventListener("seeking", () => {
        if (!isSkippingAd) {
          userSeeking = true;
        }
      });

      video.addEventListener("seeked", () => {
        if (userSeeking) {
          const videoTime = video.currentTime;
          const adDuration = skipEnd - skipStart;

          // N·∫øu tua ƒë·∫øn th·ªùi ƒëi·ªÉm sau qu·∫£ng c√°o, audio ph·∫£i l√πi l·∫°i
          if (videoTime >= skipEnd) {
            audio.currentTime = videoTime - adDuration;
            console.log(
              `üéØ Video: ${videoTime.toFixed(2)}s ‚Üí Audio: ${(
                videoTime - adDuration
              ).toFixed(2)}s (ƒë√£ tr·ª´ ${adDuration}s qu·∫£ng c√°o)`
            );
          } else {
            // N·∫øu tua ƒë·∫øn th·ªùi ƒëi·ªÉm tr∆∞·ªõc qu·∫£ng c√°o, sync b√¨nh th∆∞·ªùng
            audio.currentTime = videoTime;
          }
        }
        userSeeking = false;
        isSkippingAd = false;
      });

      // Skip ads once per episode
      video.addEventListener("timeupdate", () => {
        const t = video.currentTime;
        if (!adSkipped && t >= skipStart && t < skipEnd) {
          console.log("‚è© Skipping ads...");
          isSkippingAd = true;
          adSkipped = true;
          video.currentTime = skipEnd;
        }
      });

      // Manual sync
      syncBtn.onclick = () => {
        const videoTime = video.currentTime;
        const adDuration = skipEnd - skipStart;

        // √Åp d·ª•ng c√πng logic v·ªõi tua video
        if (videoTime >= skipEnd) {
          audio.currentTime = videoTime - adDuration;
          status.textContent = `‚úÖ ƒê√£ ƒë·ªìng b·ªô: Video ${formatTime(
            videoTime
          )} ‚Üí Audio ${formatTime(
            videoTime - adDuration
          )} (tr·ª´ ${adDuration}s ads)`;
        } else {
          audio.currentTime = videoTime;
          status.textContent = `‚úÖ ƒê√£ ƒë·ªìng b·ªô t·∫°i ${formatTime(videoTime)}`;
        }

        setTimeout(() => {
          status.textContent = `${episodes[currentEpisode].name} - ƒêang ph√°t`;
        }, 3000);
      };

      // Auto next episode
      video.addEventListener("ended", () => {
        if (currentEpisode < episodes.length - 1) {
          status.textContent = "‚è≠Ô∏è T·ª± ƒë·ªông chuy·ªÉn t·∫≠p sau 3 gi√¢y...";
          setTimeout(() => {
            loadEpisode(currentEpisode + 1);
            video.play();
          }, 3000);
        } else {
          status.textContent = "üéâ ƒê√£ xem h·∫øt t·∫•t c·∫£ t·∫≠p!";
        }
      });

      // Display sync info
      function formatTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, "0")}`;
      }

      setInterval(() => {
        if (!video.paused) {
          const drift = (video.currentTime - audio.currentTime).toFixed(2);
          document.getElementById(
            "videoTime"
          ).textContent = `Video: ${formatTime(video.currentTime)}`;
          document.getElementById(
            "audioTime"
          ).textContent = `Audio: ${formatTime(audio.currentTime)}`;
          document.getElementById("drift").textContent = `Drift: ${drift}s`;
        }
      }, 1000);

      // ===== INITIALIZE =====
      // Load data from API on startup
      initMovieSelector();
      fetchEpisodes();
    </script>
  </body>
</html>
